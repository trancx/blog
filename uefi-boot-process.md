---
description: 上节简单阐述了 UEFI 的动机以及优势，这次我们来关注它的引导过程
---

# UEFI 的引导过程

先来了解一下传统的 BIOS 引导过程，在设置页面我们会选择引导的介质，例如是哪个盘，选择之后，那个盘里的 MBR 在 BIOS 完成自检和初始化设备之后 就会被读到 0x7c00 的位置，接着一切都是操作系统的事情了，BIOS 只会提供几个中断，给操作系统一些设备的基本信息。

{% hint style="info" %}
所谓修改什么优先级，其实就是在一个数组里面的位置，而这个数组存储在断电也不会消失的内存上，所以我们修改之后关机之后依然有效
{% endhint %}

我们说了，这种方式并不好，尤其是对多操作系统的支持，其次当操作系统出错的时候，是更换一个文件来的简单，还是更换磁盘的前 512 字节容易呢？ 而且 MBR 式的引导往往是占用的不止是512字节，只是BIOS 只会读512字节，像最早期的 linux，全部都放在硬盘的最前面。而且 MBR 里面还有分区信息，更换的时候还得保证分区信息保留，也是一件麻烦的事情，而 UFEI 下的引导就没有这个问题。

首先， UEFI 摈弃了 MBR 的引导，并且把 MBR 的部分变成保留的内容（ 很明显，是为了向后兼容 ），换言之，现在硬盘的第一个扇区是被保留，是不使用的。

```bash
$ gdisk /dev/sda
    output: 
              MBR: protective  # MBR is not used in UEFI 
              BSD: not present
              APM: not present
              GPT: present

```

GPT 是一种分区表，也是 UEFI 引导的核心，我们先放着，这不影响我们从整体上理解 UEFI 的引导过程。首先，UEFI 的核心在于有一个分区，我们称之为 ESP（EFI  System Partition），可以把 EFI 理解成 UEFI，区分它们是没有意义的，也就是说有一个 ESP 分区，里面存放的就是可以引导的文件，我们操作系统的引导文件全部存放在这里。

```bash
$  ls /boot/efi  # 可以看见有一个 EFI 文件
    output: /EFI
$  cd /EFI
$  ls
    output: /BOOT /Microsoft  /centos
```

可以看出，/boot/efi 下挂载的就是 ESP 分区，里面的 EFI 是一个目录文件，所有的操作系统都会在里面建立一个属于自己操作系统目录，然后在这个目录里面存放自己的引导文件，然后增加全局变量 BOOT\#\#\#\# ，这个全局变量是

