# 地址空间

我们经常说地址，地址，其实呢，在不同的场合谈论的地址是完全不一样的，这是因为有不同的地址空间。这是抽象的结果，但是却给学习的人带来了很多误解，尤其是要涉及操作系统 ，嵌入式这些底层的人员，他们会接触到各种各样的地址空间，然后混合在一起的时候就会分不清了。

## 进程地址空间

在编程的情况下，很多人都会出现 error，尤其是刚开始接触学习一门新的语言，就连照着敲都会出错，这时候的错误可能还是显而易见的，让有经验的人来一看就明白了，但是随着编程能力的提升，有些错误就不能用肉眼发现，于是我们就有了 Debug 大法。

那么，在观察变量的时候，必然能看见这个变量所在的地址，这个地址也是我们最开始接触并了解地址这个概念，老师一般会解释为内存上的单元，于是我们也就这么记住了，当然这是方便我们理解，但是呢，深入到其他地址空间的时候必然要知道它们的区别。在我们 debug 时候，看见的地址，我们称这一类型的地址为 **进程地址**，这些也称为进程地址空间。

首先它是属于进程这一范畴，意味着所有的进程都有这么一块空间，我们以 32位 的 Linux 操作系统为例子，这一块空间就是 0～3G 这一连续空间，也就是说，每个进程都有 3G 的空间，这一空间是每个进程都会不一样的（ 实际上可能一样的，但是我们先忽略 ），我们在切换进程的时候，关键的一步就是切换到不同的进程空间，所以 CPU 操作同一地址，如果针对的是不同的进程，真正访问的地方也就不一样（ 这里我们忽略不同的进程利用映射，从而导致相同的情况 ）。

进程空间存在的意义是什么呢，考虑如果不同的进程没有自己独立的空间，那么在我们编程之后实际上需要编译器进行处理，最终得到一个可执行的文件，这个可执行的文件我们想想，CPU 是不能识别变量名的，所有的访问变量，计算以及逻辑跳转操作都是通过寻址，然后存储到寄存器，接着运算这一过程实现的，那么我们如何预知这个地址呢？也就是说，你都不知道你这个程序最终从哪里开始，如何解决变量的寻址问题和跳转的问题，以前是通过分段来实现，也就是不同的进程，我们规定一段空间给它\( 实际上，这就是一段进程空间 \)，然后进程编写的时候都从默认 0 开始，实际运行的时候，我们只需要加上一个基址就好了。

```text
考虑 a，b 两个变量存放在 0x100000 0x100004 ，这个是偏移，也就是我们可执行文件 +0x100000 的
地方存放的就是 a，同理可知 b  
0x100000    a
0x100004    b

0x100    movl %eax, [0x100000]
         movl %ebx, [0x100004]
         addl %eax, %ebx     # a =  a + b

程序偏移 0x100 的地方有一条指令，实现了 a,b 的相加        
```

现在考虑我们如果每个进程都有自己独立的空间，我们直接把程序放在自己进程空间内，那么在自己的空间， 0x100000 必然还是 a 变量，上述的代码也不需要做任何处理。如果没有这一空间，操作系统可能将程序放在了，内存 0x100000 ，那么上述所有地址，是不是都得 加上 0x100000，如果所有的程序，在执行之前都要对它进行地址修改，是不是很麻烦，并且运行起来也非常缓慢，还有一种手段，就是添加一个基址寄存器，所有的寻址都要加上这一基址寄存器，实际上就是分段的概念，比如我将基址寄存器\(  每个进程都有不同的基址寄存器 \)赋值为 0x100000，那么上述程序是不是也不需要修改了，实际上它和进程空间是一样的概念。

总之，进程空间的提出是方便了程序的编写和提高程序运行的效率。

## 内核地址空间



