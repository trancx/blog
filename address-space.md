# 地址空间

我们经常说地址，地址，其实呢，在不同的场合谈论的地址是完全不一样的，这是因为有不同的地址空间。这是抽象的结果，但是却给学习的人带来了很多误解，尤其是要涉及操作系统 ，嵌入式这些底层的人员，他们会接触到各种各样的地址空间，然后混合在一起的时候就会分不清了。

## 进程地址空间

在编程的情况下，很多人都会出现 error，尤其是刚开始接触学习一门新的语言，就连照着敲都会出错，这时候的错误可能还是显而易见的，让有经验的人来一看就明白了，但是随着编程能力的提升，有些错误就不能用肉眼发现，于是我们就有了 Debug 大法。

那么，在观察变量的时候，必然能看见这个变量所在的地址，这个地址也是我们最开始接触并了解地址这个概念，老师一般会解释为内存上的单元，于是我们也就这么记住了，当然这是方便我们理解，但是呢，深入到其他地址空间的时候必然要知道它们的区别。在我们 debug 时候，看见的地址，我们称这一类型的地址为 **进程地址**，这些也称为进程地址空间。

首先它是属于进程这一范畴，意味着所有的进程都有这么一块空间，我们以 32位 的 Linux 操作系统为例子，这一块空间就是 0～3G 这一连续空间，也就是说，每个进程都有 3G 的空间，这一空间是每个进程都会不一样的（ 实际上可能一样的，但是我们先忽略 ），我们在切换进程的时候，关键的一步就是切换到不同的进程空间，所以 CPU 操作同一地址，如果针对的是不同的进程，真正访问的地方也就不一样（ 这里我们忽略不同的进程利用映射，从而导致相同的情况 ）。

进程空间存在的意义是什么呢，考虑如果不同的进程没有自己独立的空间，那么在我们编程之后实际上需要编译器进行处理，最终得到一个可执行的文件，这个可执行的文件我们想想，CPU 是不能识别变量名的，所有的访问变量，计算以及逻辑跳转操作都是通过寻址，然后存储到寄存器，接着运算这一过程实现的，那么我们如何预知这个地址呢？也就是说，你都不知道你这个程序最终从哪里开始，如何解决变量的寻址问题和跳转的问题，以前是通过分段来实现，也就是不同的进程，我们规定一段空间给它\( 实际上，这就是一段进程空间 \)，然后进程编写的时候都从默认 0 开始，实际运行的时候，我们只需要加上一个基址就好了。

```text
考虑 a，b 两个变量存放在 0x100000 0x100004 ，这个是偏移，也就是我们可执行文件 +0x100000 的
地方存放的就是 a，同理可知 b  
0x100000    a
0x100004    b

0x100    movl %eax, [0x100000]
         movl %ebx, [0x100004]
         addl %eax, %ebx     # a =  a + b

程序偏移 0x100 的地方有一条指令，实现了 a,b 的相加        
```

现在考虑我们如果每个进程都有自己独立的空间，我们直接把程序放在自己进程空间内，那么在自己的空间， 0x100000 必然还是 a 变量，上述的代码也不需要做任何处理。如果没有这一空间，操作系统可能将程序放在了，内存 0x100000 ，那么上述所有地址，是不是都得 加上 0x100000，如果所有的程序，在执行之前都要对它进行地址修改，是不是很麻烦，并且运行起来也非常缓慢，还有一种手段，就是添加一个基址寄存器，所有的寻址都要加上这一基址寄存器，实际上就是分段的概念，比如我将基址寄存器\(  每个进程都有不同的基址寄存器 \)赋值为 0x100000，那么上述程序是不是也不需要修改了，实际上它和进程空间是一样的概念。

总之，进程空间的提出是方便了程序的编写和提高程序运行的效率。

## 内核地址空间

刚才我们说了，对于不同的进程 0～3G 是都是自己的空间，我们硬件用了一些技巧把它们隔离了，但是我们还没说，3G～4G 这块地方是什么空间呢。首先，我先说明，实际上每个进程都有自己的空间，是通过映射来实现的，简单点理解就是，CPU 执行不同进程的时候访问的相同的地址，最终是对应到不同的地址去了，也就是 CPU 看见的是假的地址，我们也称为虚拟地址。

所谓映射，就是地址转换，不同的进程，我设置不同的转换表，那么是不是相同的单元就可以转换到不同的地址了呢？最终转换的这个地址，我们称为物理地址，这个地址我们稍后再说。总之，通过这一转换，实现了不同的进程拥有"重复"的地址空间，使得我们程序的编写非常的方便。

然而，3G～4G 这一块我们映射到了相同的地址空间，什么意思呢？ 也就是在为不同的进程设置的转换表，对于 3G～4G 这一块的转换，所有的进程都是相同的，也就是说，我们任何的进程，访问 3G～4G 的地址，最终转换的地址都是相同的。

这一块所有进程共享的空间，我们称之为内核地址空间，因为这块空间最终映射\( 经过转换之后 \)的地方是存放内核代码的地方。操作系统在切换的进程的时候，切换进程的代码你有没有考虑是存放在哪里呢？其实，就是代码运行到了某一进程\( 当前正在执行 \)的 3G 以上的空间，然后完成了进程的切换，又回到了 3G 以下的空间，然而这次 3G 以下的空间，是属于新的进程，也就是切换的进程的时候，切换了转换的表\( 地址映射表 \)，所以再次回到进程空间的时候，已经是新的进程空间了。

![](.gitbook/assets/image%20%282%29.png)

我们一定要了解，所谓的地址空间，就是填写一张不同的地址转换表\( 映射表 \)，不同的进程拥有自己的表，然后表在 3G～4G 这一块映射项填写了相同的值，所以映射到了一个地方，这一块地方就是内核映像所在的地方，所以我们将这一块空间称为内核空间。

